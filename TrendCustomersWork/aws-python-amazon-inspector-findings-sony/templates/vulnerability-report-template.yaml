AWSTemplateFormatVersion: 2010-09-09
Parameters:
  AwsRegion:
    Type: String
    Description: Please enter the region in which the lambda will be executed
    Default : us-east-1
    AllowedValues:
      - us-east-1
      - us-east-2	
      - us-east-1	
      - us-west-1	
      - us-west-2
      - af-south-1
      - ap-east-1
      - ap-southeast-3
      - ap-south-1
      - ap-northeast-3
      - ap-northeast-2
      - ap-southeast-1
      - ap-southeast-2
      - ap-northeast-1
      - ca-central-1
      - eu-central-1
      - eu-west-1
      - eu-west-2
      - eu-south-1
      - eu-west-3
      - eu-north-1
      - me-south-1
      - me-central-1
      - sa-east-1
  ApiKey:
    Type: String
    NoEcho: "true"
    Description: Please enter your Cloud One API Key
  EmailSender:
    Type: String
    Description: Email address to be used for sending report
  EmailRecipients:
    Type: String
    Description: Comma separated (without spaces) email addresses for recieving report
  CronSchedule:
    Type: String
    Description: Schedule the time you would like the lambda function to run in the cron format (Default is every wednesday)
    Default: cron(0 12 ? * WED *)
  CloudOneRegion:
    Type: String
    Description: Enter your Cloud One Region
    Default: us-1
    AllowedValues:
      - trend-us-1
      - us-1
      - in-1
      - gb-1
      - jp-1
      - de-1
      - au-1
      - ca-1
      - sg-1

Resources:
  LambdaRole: 
    Type: "AWS::IAM::Role"
    Properties: 
      AssumeRolePolicyDocument: 
        Version: "2012-10-17"
        Statement: 
          - Effect: "Allow"
            Principal: 
              Service: 
                - "lambda.amazonaws.com" 
            Action: 
              - "sts:AssumeRole"  
      ManagedPolicyArns:
          - arn:aws:iam::aws:policy/AmazonVPCCrossAccountNetworkInterfaceOperations
          - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
          - arn:aws:iam::aws:policy/AmazonInspector2ReadOnlyAccess
          - arn:aws:iam::aws:policy/CloudWatchLambdaInsightsExecutionRolePolicy
          - !Ref LambdaSESWritePolicy
          - !Ref LambdaSecretAcessPolicy
  LambdaSESWritePolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Sid: VisualEditor0
          Effect: Allow
          Action:
          - ses:CreateReceiptRule
          - ses:UpdateConfigurationSetEventDestination
          - ses:SetIdentityMailFromDomain
          - ses:DeleteReceiptFilter
          - ses:VerifyEmailIdentity
          - ses:DeleteCustomVerificationEmailTemplate
          - ses:TestRenderTemplate
          - ses:CreateReceiptFilter
          - ses:DeleteReceiptRule
          - ses:DeleteConfigurationSet
          - ses:CreateConfigurationSetTrackingOptions
          - ses:UpdateAccountSendingEnabled
          - ses:DeleteConfigurationSetEventDestination
          - ses:VerifyDomainDkim
          - ses:DeleteVerifiedEmailAddress
          - ses:VerifyDomainIdentity
          - ses:CloneReceiptRuleSet
          - ses:SetIdentityHeadersInNotificationsEnabled
          - ses:SendEmail
          - ses:SendTemplatedEmail
          - ses:SendCustomVerificationEmail
          - ses:UpdateTemplate
          - ses:DeleteConfigurationSetTrackingOptions
          - ses:UpdateConfigurationSetTrackingOptions
          - ses:SetIdentityNotificationTopic
          - ses:SetIdentityDkimEnabled
          - ses:PutConfigurationSetDeliveryOptions
          - ses:VerifyEmailAddress
          - ses:UpdateReceiptRule
          - ses:CreateConfigurationSet
          - ses:UpdateConfigurationSetReputationMetricsEnabled
          - ses:DeleteReceiptRuleSet
          - ses:CreateTemplate
          - ses:SendRawEmail
          - ses:ReorderReceiptRuleSet
          - ses:SendBounce
          - ses:UpdateConfigurationSetSendingEnabled
          - ses:SetActiveReceiptRuleSet
          - ses:CreateCustomVerificationEmailTemplate
          - ses:UpdateCustomVerificationEmailTemplate
          - ses:DeleteTemplate
          - ses:CreateReceiptRuleSet
          - ses:SetReceiptRulePosition
          - ses:CreateConfigurationSetEventDestination
          - ses:SendBulkTemplatedEmail
          - ses:DeleteIdentity
          - ses:SetIdentityFeedbackForwardingEnabled
          Resource: !Sub arn:aws:ses:${AWS::Region}:${AWS::AccountId}:identity/${EmailRecipients}
  LambdaSecretAcessPolicy: 
    Type: AWS::IAM::ManagedPolicy
    Properties:
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Sid: VisualEditor0
          Effect: Allow
          Action:
          - "secretsmanager:GetSecretValue"
          - "secretsmanager:DescribeSecret"
          - "sts:AssumeRole"
          Resource: !Ref ApiKeySecret
  #   This secret holds the Trend Micro Cloud One API key.
  ApiKeySecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: "TrendMicro/CloudOne/ApiKey"
      SecretString: !Sub |
        {
          "ApiKey": "${ApiKey}"
        }
  VulnerabilityReportLambda:
    Type: "AWS::Lambda::Function"
    Properties:
      Environment:
        Variables:
          awsregion: !Ref AwsRegion
          c1_api: !Ref ApiKeySecret
          sender: !Ref EmailSender
          recipients: !Ref EmailRecipients
          cloudoneregion: !Ref CloudOneRegion
      Code:
        ZipFile: |
            from __future__ import print_function
            import os
            import json
            import csv
            import sys, warnings
            import boto3
            from pprint import pprint
            from tempfile import TemporaryFile
            from email.mime.multipart import MIMEMultipart
            from email.mime.text import MIMEText
            from email.mime.application import MIMEApplication
            from urllib.request import Request, urlopen
            from urllib.parse import urlencode


            API_VERSION = "v1"
            AWS_REGION = os.environ.get("aws_region")
            C1_API_KEY = os.environ.get("c1_api")
            SENDER = os.environ.get("sender")
            RECIPIENTS = os.environ.get("recipients")
            HOST = (
                f"https://workload.{os.environ.get('cloudoneregion')}.cloudone.trendmicro.com/api"
            )

            # get secret
            secrets = boto3.client("secretsmanager").get_secret_value(SecretId=C1_API_KEY)
            sm_data = json.loads(secrets["SecretString"])
            api_key = sm_data["ApiKey"]


            ######################################## Uncomment the following if you running on your local machine and comment the above 7 lines
            # API_VERSION = "v1"
            # AWS_REGION = "us-east-1"  ##You can input the aws region you want here
            # SENDER = "sender@email.com"
            # RECIPIENTS = "recipient@email.com"
            # HOST = "https://workload.trend-us-1.cloudone.trendmicro.com/api"
            # api_key = "YOUR CLOUD ONE API KEY"
            ############################################## END OF TEST CODE ############################################################

            HEADERS = {
                "Authorization": f"ApiKey {api_key}",
                "api-version": API_VERSION,
                "Content-Type": "application/json",
            }

            inspector = boto3.client("inspector2", AWS_REGION)
            sts = boto3.client("sts")
            sns = boto3.client("sns")
            s3 = boto3.client("s3")


            def send_email(sender, recipients, subject, html_body, attachment_details):
                print("sending email ...")
                # Create a new SES resource and specify a region.
                client = boto3.client("ses", region_name=AWS_REGION)
                msg = MIMEMultipart()
                text_part = MIMEText(html_body, _subtype="html")
                msg.attach(text_part)

                msg["To"] = recipients
                msg["From"] = sender
                msg["Subject"] = subject
                for item in attachment_details:
                    filename = item["filename"]
                    attachment = item["attachment"]
                    part = MIMEApplication(attachment.read(), filename)
                    part.add_header("Content-Disposition", "attachment", filename=filename)
                    msg.attach(part)
                client.send_raw_email(RawMessage={"Data": msg.as_bytes()})



            def get_response(url, query_parameters=None, headers=None, method="GET", data=None):
                if query_parameters:
                    url += f"?{urlencode(query_parameters)}"
                    print("formed url:", url)
                if data:
                    data = json.dumps(data)
                    # Convert to String
                    data = str(data)
                    # Convert string to byte
                    data = data.encode("utf-8")
                    # Post/Put Method is being invoked if data != None
                    req = Request(url, method=method, data=data)
                else:
                    req = Request(url)
                if headers:
                    for item in headers.items():
                        req.add_header(item[0], item[1])
                # Response
                response = json.loads(urlopen(req).read())
                return response


            def cves_from_instance(instance_id, inspector):
                cves = list()
                result = list()
                print("<<<<<<< checking instance id:", instance_id)
                resp = inspector.list_findings(
                    filterCriteria={
                        "findingStatus": [{"comparison": "EQUALS", "value": "ACTIVE"}],
                        "resourceId": [{"comparison": "EQUALS", "value": instance_id}],
                    }
                )
                result.extend(resp["findings"])
                next_token = resp.get("nextToken")
                while next_token:
                    resp = inspector.list_findings(
                        filterCriteria={
                            "findingStatus": [{"comparison": "EQUALS", "value": "ACTIVE"}],
                            "resourceId": [{"comparison": "EQUALS", "value": instance_id}],
                        },
                        nextToken=next_token,
                    )
                    result.extend(resp["findings"])
                    next_token = resp.get("nextToken")
                for finding in result:
                    cve = finding.get("packageVulnerabilityDetails", {}).get("vulnerabilityId")
                    if cve:
                        cves.append(cve)
                return cves


            def all_instances_details_from_inspector(inspector):
                instances = list()
                result = list()
                findings = inspector.list_finding_aggregations(
                    aggregationType="AWS_EC2_INSTANCE",
                )
                result.extend(findings["responses"])
                next_token = findings.get("nextToken")
                while next_token:
                    findings = inspector.list_finding_aggregations(
                        aggregationType="AWS_EC2_INSTANCE",
                        nextToken=next_token,
                    )
                    result.extend(findings["responses"])
                    next_token = findings.get("nextToken")
                for finding in result:
                    instance_details = {
                        "id": finding["ec2InstanceAggregation"]["instanceId"],
                        "name": finding["ec2InstanceAggregation"]
                        .get("instanceTags", {})
                        .get("Name"),
                        "account_id": finding["ec2InstanceAggregation"]["accountId"],
                    }
                    instances.append(instance_details)
                print("Found total instances =", len(instances))
                return instances


            def get_computer_from_instance_id(instance_id):
                search_criteria = {
                    "fieldName": "ec2VirtualMachineSummary/instanceID",
                    "stringTest": "equal",
                    "stringValue": instance_id,
                }
                payload = {
                    "searchCriteria": [search_criteria],
                }
                query_parameters = {"expand": "all"}
                computers_api = f"{HOST}/computers/search"
                response = get_response(
                    url=computers_api,
                    query_parameters=query_parameters,
                    headers=HEADERS,
                    method="POST",
                    data=payload,
                )
                computers = response["computers"]
                if computers:
                    return computers[0]


            def lambda_handler(event, context):
                csv_rows = list()
                all_instance_details = all_instances_details_from_inspector(inspector)
                for instance_details in all_instance_details:
                    instance_id = instance_details["id"]
                    instance_name = instance_details["name"]
                    account_id = instance_details["account_id"]
                    print(instance_name, instance_id)
                    this_instance_cves = cves_from_instance(instance_id, inspector)
                    print("inspector cves", len(this_instance_cves))

                    computer = get_computer_from_instance_id(instance_id)
                    if not computer:
                        print(f"No computer found for instance id: {instance_id}")
                        continue
                    print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>   id", computer["ID"])
                    if computer.get("intrusionPrevention", {}).get("ruleIDs"):
                        cves_protected_by_rules = []
                        for ipr_id in computer["intrusionPrevention"]["ruleIDs"]:
                            print(">>>>>>>>> checking rule id:", ipr_id)
                            describe_ips_url = f"{HOST}/computers/{computer['ID']}/intrusionprevention/rules/{ipr_id}"
                            ipr = get_response(url=describe_ips_url, headers=HEADERS)

                            if ipr.get("CVE"):
                                for cve in ipr["CVE"]:
                                    if cve in this_instance_cves:
                                        print(
                                            account_id,
                                            instance_id,
                                            computer["displayName"],
                                            cve,
                                            "yes"
                                        )
                                        csv_rows.append(
                                            [
                                                account_id,
                                                instance_id,
                                                computer["displayName"],
                                                cve,
                                                "yes"
                                            ]
                                        )
                                        cves_protected_by_rules.append(cve)
                        unprotected_cves = list(
                            set(this_instance_cves) - set(cves_protected_by_rules)
                        )
                        for cve in unprotected_cves:
                            csv_rows.append(
                                [
                                    account_id,
                                    instance_id,
                                    computer["displayName"],
                                    cve,
                                    "no"
                                ]
                            )
                    else:
                        for cve in this_instance_cves:
                            csv_rows.append(
                                [
                                    account_id,
                                    instance_id,
                                    computer["displayName"],
                                    cve,
                                    "no"
                                ]
                            )

                csv_header_protected_instances = [
                    "account_id",
                    "instance_id",
                    "computer",
                    "vulnerability_id",
                    "protected by Trend Micro"
                ]


                csv_file = TemporaryFile(mode="w+", newline="")
                writer = csv.writer(csv_file)

                writer.writerow(csv_header_protected_instances)
                for row in csv_rows:
                    writer.writerow(row)
                csv_file.seek(0)


                for row in csv_rows:
                    print(row)


                # The subject line for the email.
                subject = f"Vulnerability Report (CVEs) from Intrusion Prevention - {AWS_REGION}"
                protected_instances_html = '<table border="1">' + "\n"
                # write headers
                protected_instances_html += "</tr>" + "\n"
                for col in csv_header_protected_instances:
                    protected_instances_html += f"<th>{col}</th>" + "\n"
                protected_instances_html += "</tr>" + "\n"
                # write rows
                for row in csv_rows:
                    protected_instances_html += "<tr>" + "\n"
                    for col in row:
                        protected_instances_html += f"<td>{col}</td>" + "\n"
                    protected_instances_html += "</tr>" + "\n"
                protected_instances_html += "</table>"

                # The HTML body of the email.
                body_html = f"""<html>
                <head></head>
                <body>
                    <h1>Vulnerability Report from Inspector Findings</h1>
                    {protected_instances_html}
                </body>
                </html>
                """
                send_email(
                    SENDER,
                    RECIPIENTS,
                    subject,
                    body_html,
                    [
                        {"filename": "Vulnerability_report.csv", "attachment": csv_file},
                    ],
                )

            ######################################## Uncomment the following if you running on your local machine
            # lambda_handler(None, None)

      FunctionName: "vulnerability_report_lambda"
      Handler: "index.lambda_handler"
      Runtime: python3.9
      Timeout: 600
      Role: !GetAtt LambdaRole.Arn

  ScheduledRule: 
    Type: AWS::Events::Rule
    Properties: 
      Description: "ScheduledRule"
      ScheduleExpression: !Sub ${CronSchedule} 
      State: "ENABLED"
      Targets: 
        - 
          Arn: 
            Fn::GetAtt: 
              - "VulnerabilityReportLambda"
              - "Arn"
          Id: "TargetFunctionV1"
  
  PermissionForEventsToInvokeLambda: 
    Type: AWS::Lambda::Permission
    Properties: 
      FunctionName: !Ref "VulnerabilityReportLambda"
      Action: "lambda:InvokeFunction"
      Principal: "events.amazonaws.com"
      SourceArn: 
        Fn::GetAtt: 
          - "ScheduledRule"
          - "Arn"
 